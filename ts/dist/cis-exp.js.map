{"version":3,"file":"cis-exp.js","sources":["../src/cis-exp.ts"],"sourcesContent":["import {round, mround, trunc, ceil} from './math';\nimport {Complex} from './complex';\n\n// tslint:disable:no-bitwise prefer-object-spread\n\nnamespace cisTables {\n  const {PI, abs, sin, cos, sqrt, max} = Math; // const abs = (value: number) => value * ((value >= 0 || -1) as number);\n  const Base = Float32Array;\n  /**\n   * CIS Lookup Table for s₏ sin(2πn/N) and c₏ for cos(2πn/N) terms, where N\n   * is a base-2 single-term safe unsigned integer (2ⁿ) passed as the first\n   * constructor argument for the table.\n   *\n   * @see https://en.wikipedia.org/wiki/Trigonometric_tables\n   */\n  export class CISTable extends (Base as typeof Base) {\n    // private n: number; private n2: number; private n4: number; private n8: number;\n    n: [number, number, number, number];\n    constructor(public size: number) {\n      super(new SharedArrayBuffer(Base.BYTES_PER_ELEMENT * (size * 1.25)));\n      const [n, n2, n4, n8] = (this.n = [size, size >> 1, size >> 2, size >> 3]);\n      const t = sin(PI / n),\n        c0 = (this[n4] = 1),\n        s0 = (this[0] = 0),\n        n2p4 = n2 + n4;\n      const dc0 = 2 * t ** 2,\n        ds0 = max((2 - dc0) * dc0) ** 0.5,\n        t0 = 2 * dc0;\n\n      const sequential = !true;\n      if (sequential) {\n        for (let x = 0, [dc, ds, t, c, s] = [dc0, ds0, t0, c0, s0]; x < n; x++) {\n          if (x > 1 && x < n8) {\n            this[x] = s += ds;\n            ds -= t * s;\n            this[n4 - x] = c -= dc;\n            dc += t * s;\n          } else if (x > n4 - n8 && x < n4 - 1) {\n          } else if (x === n8) {\n            if (n8 !== 0) this[x] = Math.sqrt(0.5);\n          }\n\n          // const j0 = n2 - n4, jN = n2 - 0;\n          // if (x > j0 && x <= jN) {\n          //     const j = jN - x;\n          //     this[x] = this[j];\n          // }\n          // const k0 = n2 + 0, kN = n2 + n2p4;\n          // if (x >= n2 && x < n2 + n2p4) {\n          //     const k = x - k0;\n          //     this[x] = -this[k];\n          // }\n          // return this[x];\n        }\n        // for (let j = 0; j < n4; j++) this[n2 - j] = this[j]; // lim = n4\n        for (let j = n2; j > n2 - n4; j--) this[j] = this[n2 - j];\n      } else {\n        for (\n          let i = 1, [dc, ds, t, c, s] = [dc0, ds0, t0, c0, s0];\n          i < n8;\n          i++ // dc = dc0, ds = ds0, t = t0, c = c0, s = s0; // c -= dc, dc += t * c, s += ds, ds -= t * s,\n        )\n          (this[i] = s += ds), (ds -= t * s), (this[n4 - i] = c -= dc), (dc += t * c); // c -= dc, dc += t * c, s += ds, ds -= t * s, this[i] = s, this[n4 - i] = c;\n        if (n8 !== 0) this[n8] = 0.5 ** 0.5; // ** 0.5;\n        for (let j = 0; j < n4; j++) this[n2 - j] = this[j]; // lim = n4\n        for (let k = 0; k < n2p4; k++) this[n2 + k] = -this[k]; // lim = n2 + n4\n      }\n    }\n  }\n  const tables = new Map<number, CISTable>();\n  export const get = (size: number) => (!tables.has(size) && tables.set(size, new CISTable(size)), tables.get(size));\n}\n\ndeclare function cisTables(size: number): cisTables.CISTable;\n(cisTables as any) = Object.assign(cisTables.get, cisTables);\nglobalThis['cisTables'] = cisTables;\n\nexport {cisTables};\n\nexport namespace cisExp {\n  const {PI, abs, sin, cos} = Math; // const abs = (value: number) => value * ((value >= 0 || -1) as number);\n\n  const period = PI * 2,\n    significance = PI * 64;\n  const length = ceil(period * significance * 2) * 2;\n  export const buffer = new SharedArrayBuffer(length * 4);\n  const table = new Float32Array(buffer).fill(-Infinity);\n\n  export const create = x => [cos(x), sin(x)];\n  export const get = (\n    x,\n    xt = ~~(((x % period) + period) * significance),\n    i = xt * 2,\n    ei = table[i],\n    ej = table[i + 1],\n  ) => (ei !== -Infinity || ((table[i] = ei = cos((x = xt / significance))), (table[i + 1] = ej = sin(x))), [ei, ej]);\n}\n\nexport declare function cisExp(x: number): [number, number];\n(cisExp as any) = Object.assign(cisExp.get, cisExp);\n\n// const period = PI2, significance = PI64;\n// const table = new Float32Array(ceil(period * significance * 2) * 2).fill(-Infinity);\n\n// export const create = (x) => [cos(x), sin(x)];\n// export const cisExp = (x, xt = ~~(((x % period) + period) * significance), i = xt * 2, ei = table[i], ej = table[i + 1]) => (\n//     ei !== -Infinity || (table[i] = ei = cos(x = xt / significance), table[i + 1] = ej = sin(x)), [ei, ej]\n// );\n\nexport default cisExp;\n\n// const cisExpA = (x) => [cos(x), sin(x)];\n// const cisExpO = (x) => new Complex(cos(x), sin(x));\n\n// const cisExpsM = new Map<number, any>();\n// const cisExpM = (x, xp = mround(x % PI4, PI64), exp = cisExpsM.get(xp)) => (!exp && (exp = cisExpA(xp / PI64), cisExpsM.set(xp, exp)), exp);\n\n// // const cisExpsT = new Float32Array(ceil(PI4 * PI64) * 2);\n// // const cisExpT = (x, xt = ~~((x % PI4) * PIn), i = xt * 2, exp = cisExpsT[i]) => (!exp && cisExpsT.set(cisExpA(xt / PIn), i), [cisExpsT[i], cisExpsT[i + 1]]);\n// const PImod = PI2, PIround = PI64;\n// const cisExpsT = new Float32Array(ceil(PImod * PIround * 2) * 2);\n// const cisExpT = (x, xt = ~~(((x % PImod) + PImod) * PIround), i = xt * 2, exp = cisExpsT[i]) => (!exp && cisExpsT.set(cisExpA((xt / PIround) - PImod), i), [cisExpsT[i], cisExpsT[i + 1]]);\n// // const cisExpT = (x, xt = ~~(((x % PI4) + PI4) * PI64), i = (xt * 2), exp = cisExpsT[i]) => (!exp && cisExpsT.set(cisExpA((xt / PI64) - PI4), i), [cisExpsT[i], cisExpsT[i + 1]]);\n\n// // const cast = (value) => (cast['array'][0] = abs(value), cast['array'][0]); cast['array'] = new Uint16Array(1);\n// const cast = Object.assign((value) => (cast['array'][0] = value, cast['array'][0]), { array: new Uint16Array(1) });\n// const cisExpsC = new Float32Array(ceil(PI4 * PI64) * 2);\n// const cisExpC = (x, xc = cast((x % PI4) * PI64), i = xc * 2, exp = cisExpsC[i]) => (!exp && cisExpsC.set(cisExpA(xc / PI64), i), [cisExpsC[i], cisExpsC[i + 1]]);\n\n// export const cisExp: (value: number) => [number, number] = cisExpT as any; // () => [0, 0];\n// export default cisExp;\n\n// function testCisExp() {\n//     console.info('testCisExp: started');\n//     cisExpsM.clear();\n//     cisExpsT.fill(null, 0, cisExpsT.length);\n//     cisExpsC.fill(null, 0, cisExpsC.length);\n\n//     const dimensions = [256, 1024, 2048, 4096];\n//     const methods = { array: cisExpA, complex: cisExpO, ['map/mround']: cisExpM, ['table/cast']: cisExpC, ['table/trunc']: cisExpT }; // as Array<(value: number) => any>;\n//     const totals: { [name: string]: number } = {};\n//     const cycles: object[] = [];\n//     const tround = (value: number) => mround(value || 0, 20);\n//     let ids = Object.keys(methods).sort().reverse();\n//     for (const dimension of dimensions) {\n//         const size = dimension ** 2;\n//         for (let n = 0; n < 4; n++) {\n//             const cycle = { size };\n//             totals.size = (totals.size || 0) + size;\n//             for (const id of (ids = ids.reverse())) {\n//                 const method = methods[id];\n//                 const start = performance.now();\n//                 for (let k = 0; k < size; k++) method(k); // for (let m = 0; m < reps; m++)\n//                 const elapsed = performance.now() - start;\n//                 cycle[id] = tround(elapsed), totals[id] = (totals[id] || 0) + elapsed;\n//             }\n//             cycles.push(cycle);\n//         }\n//     }\n//     for (const id of (ids = ids.reverse())) totals[id] = tround(totals[id]);\n//     const results = { ...cycles.reduce((cycles: any, cycle, i) => (cycles[`${i + 1}`.padStart(2, '0')] = cycle, cycles), {}), totals };\n//     console.group('testCisExp');\n//     console.table(results), console.log(methods, totals);\n//     console.log({ cisExpsT, cisExpsC });\n//     console.groupEnd();\n//     console.info('testCisExp: complete');\n// }\n\n// // setTimeout(testCisExp, 5000);\n\n// // const PI2 = Math.PI * 2, PI4 = Math.PI * 4, PI42 = PI4 * PI4; const cisExps = new Map<number, Complex>();\n// // const cisExp = (x, xp = mround(x % PI4, PI42), exp = cisExps.get(xp)) => (!exp && (exp = new Complex(Math.cos(xp), Math.sin(xp)), cisExps.set(xp, exp)), exp);\n\n// // const cisExp4t = (x, xt = trunc((x % PI4) * PI42), axt = xt < 0 ? xt * -1 : xt, exp = cisExps4t[axt * 2]) => (!exp && cisExps4t.set([Math.cos(x = axt / PI42), Math.sin(x)], axt * 2), [cisExps4t[axt * 2], cisExps4t[axt * 2 + 1]]);\n// // const cisExp4t = (x, xt = trunc((x % PI4) * PI42) * ((x >= 0 || -1) as number), exp = cisExps4t[xt * 2]) => (!exp && cisExps4t.set([Math.cos(x = xt / PI42), Math.sin(x)], xt * 2), [cisExps4t[xt * 2], cisExps4t[xt * 2 + 1]]);\n// // const cisExp4t = (x, xt = trunc((x % PI4) * PI42) * ((x >= 0 || -1) as number), i = xt * 2, exp = cisExps4t[i]) => (!exp && cisExps4t.set([Math.cos(x = xt / PI42), Math.sin(x)], i), cisExps4t.slice(i, i + 2));\n"],"names":[],"mappings":"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"}