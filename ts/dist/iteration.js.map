{"version":3,"file":"iteration.js","sources":["../src/iteration.ts"],"sourcesContent":["/// <reference path='./types/types.d.ts' />\n/// <reference path='./types/window.d.ts' />\n\nexport type Iteration = [number, number, number, number];\n\nconst {\n  window: {requestIdleCallback, navigator: {hardwareConcurrency = 1} = {} as Window['navigator']} = {} as Window,\n} = globalThis;\n\nconst now =\n  typeof performance !== 'undefined' && performance.now ? performance.now.bind(performance) : Date.now.bind(Date);\n\nexport function* generator(size = 0, start = 0, offset = 0, step = 1, iterations?: Iteration[]) {\n  const yields = !iterations,\n    nextSize = size >> 1,\n    nextStep = step << 1,\n    nextStart = start + nextSize,\n    nextOffset = offset + step; // tslint:disable-line:no-bitwise\n  iterations = iterations || [];\n\n  size > 1 &&\n    (generator(nextSize, start, offset, nextStep, iterations).next(),\n    generator(nextSize, nextStart, nextOffset, nextStep, iterations).next());\n\n  size >= 1 && (iterations.push([size, start, offset, step]), yields && (yield* iterations));\n\n  return iterations;\n}\n\nconst iterators = new Map<number, Iteration[]>();\n\nexport function generate(size = 0, start = 0, offset = 0, step = 1): Iteration[] {\n  let iterations: Iteration[];\n\n  if (!start && !offset && step === 1) {\n    if (iterators.has(size)) return iterators.get(size);\n\n    const started = now();\n\n    generator(size, start, offset, step, (iterations = [])).next();\n\n    const ended = now();\n    const elapsed = ended - started;\n\n    requestIdleCallback(() =>\n      console.info(`FFT: ▷ ${(size ** 0.5).toFixed(0)}² × ${iterations.length} ops / ${elapsed.toFixed(1)}ms`),\n    );\n\n    iterators.set(size, iterations);\n  } else {\n    iterations = Array.from(generator(size, start, offset, step)) as Iteration[];\n  }\n  return iterations;\n}\n\nconst N128 = 128 ** 2,\n  N256 = 256 ** 2,\n  N512 = 512 ** 2,\n  N1024 = 1024 ** 2,\n  N2048 = 2048 ** 2;\n\nexport function iterate(\n  {start = 0, offset = 0, size = 0, step = 1, remaining = true, completed = 0}: FFTIteration,\n  callback: (size?: number, start?: number, offset?: number, step?: number) => boolean,\n): Iteration[] {\n  const iterations = (!start && !offset && step === 1 && iterators.get(size)) || generate(size); // FFTIteration[];\n\n  let i;\n\n  const length = iterations.length;\n  const started = now();\n\n  for (i = 0; i < length && callback(...iterations[i]) !== false; i++); // for (const iteration of iterations) if (/* iteration.remaining = remaining--, */ apply(iteration) === false) break;\n\n  const ended = now(),\n    elapsed = ended - started,\n    operations = i,\n    aborted = i < length - 1;\n\n  requestIdleCallback(() =>\n    console[aborted ? 'warn' : 'info'](\n      `FFT: ▶︎ ${(size ** 0.5).toFixed(0)}² × ${(operations / 1000).toFixed(1)}k ops / ${elapsed.toFixed(1)}ms`,\n    ),\n  );\n\n  return iterations;\n}\n\nconst pregenerate = (size: number, timeout: number = size ** 0.5) =>\n  new Promise((resolve, reject) =>\n    requestIdleCallback(() => (console.log(`FFT: ⚡︎ ${(size ** 0.5).toFixed(0)}²`), resolve(generate(size))), {\n      timeout,\n    }),\n  );\n\nexport default iterate;\n\n// setTimeout(async (size = 1024) => ( // Promise.all([\n//     await pregenerate(size ** 2),\n//     await pregenerate((size = size * 2) ** 2),\n//     await pregenerate((size = size * 2) ** 2),\n//     true\n// ), 5000);\n\n// export function* iterations({ start = 0, offset = 0, size = 0, step = 1 }: FFTIteration = {}, result?): IterableIterator<FFTIteration> { // } = Array(size * 2 - 1))\n//     // if (size > 1) {\n//     //     const nextSize = size / 2, nextStep = 2 * step, nextStart = start + nextSize, nextOffset = offset + step;\n\n//     //     yield* iteration({ start, offset, size: nextSize, step: nextStep } as FFTIteration);\n\n//     //     yield* iteration({ start: nextStart, offset: nextOffset, size: nextSize, step: nextStep } as FFTIteration);\n\n//     // } // else if (size === 1) yield { start, offset, size, step } as FFTIteration;\n\n// }\n\n// export function iterate({ start = 0, offset = 0, size = 0, step = 1, remaining = true, completed = 0 }: FFTIteration, apply: (iteration: FFTIteration) => any) {\n// const iterator = fftIteration({ start, offset, size, step });\n\n// const started = performance.now();\n\n// for (let iteration = iterator.next(); !iteration.done && apply(iteration.value) || (remaining = !iteration.done); iteration = iterator.next(), (completed as number)++);\n\n// const ended = performance.now(), elapsed = ended - started; // operations = i, aborted = i < length - 1;\n\n// requestIdleCallback(() => (\n//     console[remaining ? 'warn' : 'info'](`FFT: ▶︎ ${(size ** 0.5).toFixed(0)}² × ${((completed as number) / 1000).toFixed(1)}k ops / ${(elapsed).toFixed(1)}ms`) // { start, offset, size, step, elapsed, operations, aborted })\n// ));\n\n// }\n\n// let lastIterator: FFTIteration & { iterator?: Iterable<FFTIteration>; iterations?: FFTIteration[] };\n\n// export function applyFFT({ start = 0, offset = 0, size = 0, step = 1 }: FFTIteration, apply: (iteration: FFTIteration) => any) {\n//     let aborted = false;  // iterations: FFTIteration[],\n//     const reusable = ({ iterations = [], iterations: { length = 0 }, start: _start, offset: _offset, size: _size }: Partial<typeof lastIterator>) => length && (start === _start) && (offset === _offset) && (size === _size) || false;\n\n//     if (lastIterator && reusable(lastIterator)) { // lastIterator.iterations && lastIterator.iterations.length && lastIterator.start === start && lastIterator.offset === offset && lastIterator.size === size && lastIterator.step === step) {\n//         const iterations = lastIterator.iterations;\n\n//         for (let i = 0; !aborted && i < iterations.length; i++) {\n//             aborted = aborted || apply(iterations[i]) === false;\n\n//         }\n//         return iterations;\n\n//     } else {\n//         lastIterator = { start, offset, size, step };\n\n//         const iterator = lastIterator.iterator = fftIteration(lastIterator), iterations = lastIterator.iterations = [];\n\n//         for (const iteration of iterations) {\n//             iterations.push(iteration), (aborted || (aborted = aborted || apply(iteration) === false));\n\n//         }\n//         return iterations;\n\n//     }\n//     // for (const iteration of iterations) apply(iteration);\n\n// }\n"],"names":[],"mappings":"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"}